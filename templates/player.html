{% extends 'base_new.html' %}

{% block title %}{{ anime.title }} - S{{ season.season_number }}E{{ episode.episode_number }} - Anime Zone{% endblock %}

{% block content %}
<div class="container" style="margin-top: 2rem;">
    <!-- Breadcrumb -->
    <div style="margin-bottom: 1.5rem;">
        <a href="/" style="color: var(--text-secondary);">Accueil</a>
        <span style="color: var(--text-muted); margin: 0 0.5rem;">/</span>
        <a href="/anime/{{ anime.anime_id if anime.anime_id else anime.id }}" style="color: var(--text-secondary);">{{ anime.title }}</a>
        <span style="color: var(--text-muted); margin: 0 0.5rem;">/</span>
        <span style="color: var(--text-primary);">S{{ season.season_number }}E{{ episode.episode_number }}: {{ episode.title }}</span>
    </div>

    <!-- Video Player -->
    <div class="video-container">
        <div class="player-wrapper">
            <!-- Lecteur vid√©o HLS (pour Vidmoly et SendVid) -->
            <video id="hls-player" 
                   controls 
                   playsinline
                   style="width: 100%; height: 100%; background: #000; display: none;">
            </video>
            
            <!-- Iframe (pour tous les autres lecteurs) -->
            <iframe id="iframe-player" 
                    src="{{ download_url }}" 
                    allow="autoplay; fullscreen" 
                    frameborder="0"
                    referrerpolicy="no-referrer"
                    allowfullscreen
                    style="width: 100%; height: 100%; border: none; display: none;">
            </iframe>
            
            <!-- Message de chargement -->
            <div id="loading-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10;">
                <div style="text-align: center; color: white;">
                    <div class="spinner-border" role="status" style="width: 3rem; height: 3rem; margin-bottom: 1rem;">
                        <span class="visually-hidden">Chargement...</span>
                    </div>
                    <p id="loading-text">D√©tection du lecteur...</p>
                </div>
            </div>

            <!-- Triple tap indicators -->
            <div id="tap-indicator-left" class="tap-indicator left">
                <i class="fas fa-backward"></i>
            </div>
            <div id="tap-indicator-right" class="tap-indicator right">
                <i class="fas fa-forward"></i>
            </div>
            <div id="tap-text" class="tap-text"></div>
        </div>
    </div>

    <!-- Information sur la source vid√©o -->
    <div style="margin-top: 0.5rem; margin-bottom: 1rem; text-align: center; font-size: 0.85rem; color: var(--text-muted);">
        <span id="source-info">
            Source: Chargement...
        </span>
        <span id="current-lang" style="margin-left: 0.5rem; color: var(--accent-color); font-weight: 600;"></span>
    </div>

    <!-- Episode Info -->
    <div style="margin-bottom: 2rem;">
        <h1 style="font-size: 1.75rem; margin-bottom: 0.5rem;">{{ episode.title }}</h1>
        <div style="display: flex; align-items: center; margin-bottom: 1rem;">
            <span style="color: var(--accent-color); font-weight: 600;">Saison {{ season.season_number }}, √âpisode {{ episode.episode_number }}</span>
            <span style="margin: 0 0.75rem; color: var(--text-muted);">‚Ä¢</span>
            <span style="color: var(--text-secondary);">{{ anime.title }}</span>
        </div>
        <p style="color: var(--text-secondary);">{{ episode.description }}</p>
    </div>

    <!-- Episode Navigation -->
    <div class="player-controls">
        <div class="episode-navigation">
            <!-- Previous Episode Button -->
            {% if episode.episode_number > 1 %}
            <a href="/player/{{ anime.anime_id if anime.anime_id else anime.id }}/{{ season.season_number }}/{{ episode.episode_number - 1 }}" class="btn btn-outline">
                <i class="fas fa-step-backward"></i> √âpisode pr√©c√©dent
            </a>
            {% else %}
            <button class="btn btn-outline" disabled style="opacity: 0.5;">
                <i class="fas fa-step-backward"></i> √âpisode pr√©c√©dent
            </button>
            {% endif %}

            <!-- Language Selection Buttons (only if both VF and VOSTFR are available) -->
            {% set has_vf = episode.urls and episode.urls.get('VF') %}
            {% set has_vostfr = episode.urls and episode.urls.get('VOSTFR') %}
            
            {% if has_vf and has_vostfr %}
            <div class="language-selector" style="display: flex; gap: 0.5rem;">
                <button id="btn-vf" onclick="switchLanguage('VF')" class="btn btn-outline lang-btn">
                    <i class="fas fa-language"></i> VF
                </button>
                <button id="btn-vostfr" onclick="switchLanguage('VOSTFR')" class="btn btn-outline lang-btn">
                    <i class="fas fa-closed-captioning"></i> VOSTFR
                </button>
            </div>
            {% endif %}

            <!-- Download Button -->
            <button id="downloadBtn" onclick="downloadEpisode()" class="btn btn-primary">
                <i class="fas fa-download"></i> T√©l√©charger
            </button>
            <div id="downloadProgress" style="display:none; margin-top: 5px;">
                <div class="progress" style="height: 10px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 100%"></div>
                </div>
                <span id="downloadText" style="font-size: 0.8rem; color: var(--text-muted); margin-top: 5px;"></span>
            </div>

            <!-- Next Episode Button -->
            {% if episode.episode_number < season.episodes|length %}
            <a href="/player/{{ anime.anime_id if anime.anime_id else anime.id }}/{{ season.season_number }}/{{ episode.episode_number + 1 }}" class="btn btn-outline next-episode">
                √âpisode suivant <i class="fas fa-step-forward"></i>
            </a>
            {% else %}
            <button class="btn btn-outline" disabled style="opacity: 0.5;">
                √âpisode suivant <i class="fas fa-step-forward"></i>
            </button>
            {% endif %}
        </div>

        <a href="/anime/{{ anime.anime_id if anime.anime_id else anime.id }}" class="btn btn-primary">
            <i class="fas fa-list"></i> Tous les √©pisodes
        </a>
    </div>
</div>
{% endblock %}

{% block styles %}
<style>
    .video-container {
        position: relative;
        width: 100%;
        background: #000;
        border-radius: 8px;
        overflow: hidden;
    }

    .player-wrapper {
        position: relative;
        width: 100%;
        height: 0;
        padding-bottom: 56.25%;
        background-color: #000;
        overflow: hidden;
    }

    .player-wrapper video,
    .player-wrapper iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: none;
        z-index: 1;
    }

    .spinner-border {
        border: 0.25em solid rgba(255, 255, 255, 0.2);
        border-right-color: #fff;
        border-radius: 50%;
        animation: spinner-border 0.75s linear infinite;
    }

    @keyframes spinner-border {
        to { transform: rotate(360deg); }
    }

    .language-selector .lang-btn {
        min-width: 80px;
        transition: all 0.3s ease;
    }

    .language-selector .lang-btn.active {
        background: var(--accent-color);
        color: white;
        border-color: var(--accent-color);
    }

    .language-selector .lang-btn:hover:not(.active) {
        background: rgba(var(--accent-color-rgb), 0.1);
    }

    /* Triple tap indicators */
    .tap-indicator {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 20px;
        border-radius: 50%;
        font-size: 24px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 100;
    }

    .tap-indicator.show {
        opacity: 1;
        animation: tapPulse 0.3s ease;
    }

    .tap-indicator.left {
        left: 20px;
    }

    .tap-indicator.right {
        right: 20px;
    }

    @keyframes tapPulse {
        0% { transform: translateY(-50%) scale(0.8); }
        50% { transform: translateY(-50%) scale(1.2); }
        100% { transform: translateY(-50%) scale(1); }
    }

    .tap-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 14px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 101;
        white-space: nowrap;
    }

    .tap-text.show {
        opacity: 1;
    }
</style>
{% endblock %}

{% block scripts %}
<!-- HLS.js pour la lecture des vid√©os segment√©es -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

{% if current_user.is_authenticated %}
<script>
    const animeId = {{ anime.anime_id if anime.anime_id else anime.id }};
    const seasonNumber = {{ season.season_number }};
    const episodeNumber = {{ episode.episode_number }};
    
    // Available video URLs by language
    const videoUrls = {{ episode.urls | tojson | safe }};
    
    let currentLanguage = "{{ episode_lang }}";
    let videoUrl = "{{ download_url }}";
    
    let hlsPlayer = null;
    let currentVideoKey = null;
    let useSegmentation = false;
    let playerInitialized = false;

    document.addEventListener('DOMContentLoaded', function() {
        // Highlight the current language button
        updateLanguageButtons();
        
        // Enregistrer la progression initiale
        saveProgress(0, false);
        
        // Initialize player
        initializePlayer();

        // Initialize triple tap controls
        initializeTripleTap();
    });

    function updateLanguageButtons() {
        const btnVf = document.getElementById('btn-vf');
        const btnVostfr = document.getElementById('btn-vostfr');
        const currentLangSpan = document.getElementById('current-lang');
        
        if (btnVf && btnVostfr) {
            btnVf.classList.remove('active');
            btnVostfr.classList.remove('active');
            
            if (currentLanguage === 'VF') {
                btnVf.classList.add('active');
                currentLangSpan.textContent = 'üéôÔ∏è Version Fran√ßaise';
            } else if (currentLanguage === 'VOSTFR') {
                btnVostfr.classList.add('active');
                currentLangSpan.textContent = 'üìù Version Sous-titr√©e';
            }
        } else {
            // Si un seul langue disponible
            if (currentLanguage === 'VF') {
                currentLangSpan.textContent = 'üéôÔ∏è Version Fran√ßaise';
            } else if (currentLanguage === 'VOSTFR') {
                currentLangSpan.textContent = 'üìù Version Sous-titr√©e';
            }
        }
    }

    function switchLanguage(lang) {
        if (!videoUrls[lang] || videoUrls[lang].length === 0) {
            console.warn(`‚ö†Ô∏è ${lang} non disponible`);
            return;
        }
        
        // Select best URL for the language
        const urls = videoUrls[lang];
        const selectedUrl = selectBestUrl(urls);
        
        if (!selectedUrl) {
            console.error(`‚ùå Pas d'URL valide pour ${lang}`);
            return;
        }
        
        console.log(`üîÑ Changement vers ${lang}: ${selectedUrl}`);
        
        // Update global variables
        currentLanguage = lang;
        videoUrl = selectedUrl;
        
        // Update UI
        updateLanguageButtons();
        
        // Cleanup existing player
        cleanupPlayer();
        
        // Reinitialize player with new URL
        initializePlayer();
    }

    function selectBestUrl(urls) {
        if (!urls || urls.length === 0) return null;
        if (typeof urls === 'string') return urls;
        
        // Priority: vidmoly > sendvid > sibnet > others
        const vidmoly = urls.find(u => u.toLowerCase().includes('vidmoly'));
        if (vidmoly) return vidmoly;
        
        const sendvid = urls.find(u => u.toLowerCase().includes('sendvid'));
        if (sendvid) return sendvid;
        
        const sibnet = urls.find(u => u.toLowerCase().includes('sibnet'));
        if (sibnet) return sibnet;
        
        return urls[0];
    }

    function cleanupPlayer() {
        // Stop HLS player
        if (hlsPlayer) {
            hlsPlayer.destroy();
            hlsPlayer = null;
        }
        
        // Reset video elements
        const hlsPlayerElement = document.getElementById('hls-player');
        const iframePlayer = document.getElementById('iframe-player');
        const loadingOverlay = document.getElementById('loading-overlay');
        
        hlsPlayerElement.src = '';
        hlsPlayerElement.style.display = 'none';
        iframePlayer.src = '';
        iframePlayer.style.display = 'none';
        loadingOverlay.style.display = 'flex';
        
        playerInitialized = false;
        currentVideoKey = null;
        useSegmentation = false;
    }

    function initializePlayer() {
        // Ensure URL is in embed format for SendVid
        let finalUrl = videoUrl;
        if (finalUrl.includes('sendvid.com') && !finalUrl.includes('/embed/')) {
            const videoId = finalUrl.split('/').pop().split('.')[0];
            finalUrl = `https://sendvid.com/embed/${videoId}`;
        }
        
        // D√©terminer le type de lecteur
        const videoUrlLower = finalUrl.toLowerCase();
        
        // D√©tecter UNIQUEMENT Vidmoly et SendVid pour la segmentation
        if (videoUrlLower.includes('vidmoly') || videoUrlLower.includes('sendvid')) {
            console.log('üé¨ Lecteur segment√© d√©tect√©:', finalUrl);
            useSegmentation = true;
            initializeSegmentedPlayer(finalUrl);
        } else {
            // Tous les autres lecteurs ‚Üí iframe directement
            console.log('üñºÔ∏è Lecteur iframe:', finalUrl);
            useIframePlayer(finalUrl);
        }
    }

    // Utiliser le lecteur iframe (pour tous les lecteurs non support√©s)
    function useIframePlayer(url) {
        const iframePlayer = document.getElementById('iframe-player');
        const loadingOverlay = document.getElementById('loading-overlay');
        const sourceInfo = document.getElementById('source-info');
        
        // D√©tecter le type de lecteur
        let playerName = 'Lecteur externe';
        const urlLower = url.toLowerCase();
        
        if (urlLower.includes('sibnet')) playerName = 'Sibnet';
        else if (urlLower.includes('oneupload')) playerName = 'OneUpload';
        else if (urlLower.includes('mixdrop')) playerName = 'MixDrop';
        else if (urlLower.includes('doodstream')) playerName = 'DoodStream';
        else if (urlLower.includes('streamwish')) playerName = 'StreamWish';
        else if (urlLower.includes('streamtape')) playerName = 'StreamTape';
        else if (urlLower.includes('drive.google.com')) playerName = 'Google Drive';
        
        sourceInfo.textContent = `Source: ${playerName} (iframe)`;
        
        // Afficher l'iframe
        iframePlayer.src = url;
        iframePlayer.style.display = 'block';
        loadingOverlay.style.display = 'none';
        playerInitialized = true;
        
        console.log('‚úÖ Iframe initialis√©e:', playerName);
    }

    async function initializeSegmentedPlayer(url) {
        const hlsPlayerElement = document.getElementById('hls-player');
        const iframePlayer = document.getElementById('iframe-player');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const sourceInfo = document.getElementById('source-info');
        
        loadingText.textContent = 'D√©tection du type de lecteur...';
        
        try {
            const infoResponse = await fetch('/api/video/info', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: url })
            });
            
            const info = await infoResponse.json();
            
            if (!info.success) {
                console.warn('‚ö†Ô∏è Segmentation non disponible:', info.error);
                
                if (info.use_iframe) {
                    loadingText.textContent = 'Chargement avec lecteur standard...';
                    setTimeout(() => {
                        useIframePlayer(url);
                    }, 1000);
                    return;
                }
                
                throw new Error(info.error || '√âchec de la d√©tection');
            }
            
            currentVideoKey = info.video_key;
            const playerType = info.player_type.toUpperCase();
            
            console.log(`‚úÖ ${playerType} d√©tect√©`);
            
            if (info.player_type === 'sendvid' && info.direct_mp4) {
                console.log('üé¨ SendVid d√©tect√© : utilisation lecteur HTML5 natif');
                console.log('üìä √âtat initial:', {
                    display: hlsPlayerElement.style.display,
                    zIndex: hlsPlayerElement.style.zIndex,
                    overlayDisplay: loadingOverlay.style.display
                });
                
                sourceInfo.textContent = `Source: SENDVID (Streaming MP4 direct)`;
                loadingText.textContent = 'Chargement SendVid...';
                
                const streamUrl = `/api/video/stream/${encodeURIComponent(currentVideoKey)}`;
                
                // Force l'affichage de la vid√©o
                hlsPlayerElement.style.position = 'absolute';
                hlsPlayerElement.style.top = '0';
                hlsPlayerElement.style.left = '0';
                hlsPlayerElement.style.width = '100%';
                hlsPlayerElement.style.height = '100%';
                hlsPlayerElement.style.display = 'block';
                hlsPlayerElement.style.zIndex = '5';
                hlsPlayerElement.controls = true;
                
                console.log('üìä √âtat apr√®s config:', {
                    display: hlsPlayerElement.style.display,
                    zIndex: hlsPlayerElement.style.zIndex,
                    position: hlsPlayerElement.style.position
                });
                
                // Cacher le loading IMM√âDIATEMENT
                loadingOverlay.style.display = 'none';
                console.log('üëÅÔ∏è Loading overlay cach√©');
                
                hlsPlayerElement.src = streamUrl;
                hlsPlayerElement.load();
                
                playerInitialized = true;
                console.log('‚úÖ Lecteur SendVid configur√© et pr√™t');
                
                hlsPlayerElement.addEventListener('loadstart', () => {
                    console.log('üì• D√©but du chargement de la vid√©o');
                }, { once: true });
                
                hlsPlayerElement.addEventListener('loadeddata', () => {
                    console.log('üì¶ Donn√©es vid√©o charg√©es');
                }, { once: true });
                
                hlsPlayerElement.addEventListener('canplay', () => {
                    console.log('‚ñ∂Ô∏è Vid√©o pr√™te √† jouer');
                }, { once: true });
                
                hlsPlayerElement.addEventListener('loadedmetadata', () => {
                    console.log('üìä M√©tadonn√©es charg√©es, dur√©e:', hlsPlayerElement.duration);
                    
                    const savedTime = {{ time_position }};
                    if (savedTime > 0 && savedTime < hlsPlayerElement.duration) {
                        hlsPlayerElement.currentTime = savedTime;
                        console.log('‚è© Position restaur√©e:', savedTime);
                    }
                    
                    hlsPlayerElement.play().catch(err => {
                        console.warn('‚ö†Ô∏è Autoplay bloqu√©:', err);
                    });
                    
                    console.log('‚úÖ Lecteur SendVid MP4 compl√®tement initialis√©');
                }, { once: true });
                
                hlsPlayerElement.addEventListener('error', (e) => {
                    console.error('‚ùå Erreur lecteur SendVid:', e);
                    const error = hlsPlayerElement.error;
                    if (error) {
                        console.error(`Code: ${error.code}, Message: ${error.message}`);
                    }
                    loadingText.textContent = 'Erreur de lecture. Passage √† l\'iframe...';
                    setTimeout(() => {
                        useIframePlayer(url);
                    }, 2000);
                });
                
                hlsPlayerElement.addEventListener('timeupdate', () => {
                    if (hlsPlayerElement.currentTime > 0 && !hlsPlayerElement.paused) {
                        saveProgressThrottled(hlsPlayerElement.currentTime);
                    }
                });
                
                hlsPlayerElement.addEventListener('ended', () => {
                    saveProgress(hlsPlayerElement.duration, true);
                });
                
            } else {
                console.log('üé¨ Vidmoly d√©tect√© : utilisation HLS.js');
                
                sourceInfo.textContent = `Source: ${playerType} (HLS Segment√© - ${info.segments || '?'} segments)`;
                loadingText.textContent = `Chargement ${playerType}...`;
                
                const streamUrl = `/api/video/stream/${encodeURIComponent(currentVideoKey)}`;
                
                if (Hls.isSupported()) {
                    hlsPlayer = new Hls({
                        debug: false,
                        enableWorker: true,
                        lowLatencyMode: false,
                        backBufferLength: 90,
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60,
                        maxBufferSize: 60 * 1000 * 1000,
                        maxBufferHole: 0.5,
                        highBufferWatchdogPeriod: 3,
                        nudgeOffset: 0.1,
                        nudgeMaxRetry: 5,
                        manifestLoadingTimeOut: 20000,
                        manifestLoadingMaxRetry: 4,
                        levelLoadingTimeOut: 20000,
                        levelLoadingMaxRetry: 4,
                        fragLoadingTimeOut: 30000,
                        fragLoadingMaxRetry: 6
                    });
                    
                    hlsPlayer.loadSource(streamUrl);
                    hlsPlayer.attachMedia(hlsPlayerElement);
                    
                    let nonFatalErrorCount = 0;
                    const MAX_NON_FATAL_ERRORS = 10;
                    
                    hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                        loadingOverlay.style.display = 'none';
                        hlsPlayerElement.style.display = 'block';
                        playerInitialized = true;
                        
                        const savedTime = {{ time_position }};
                        if (savedTime > 0) {
                            hlsPlayerElement.currentTime = savedTime;
                        }
                        
                        hlsPlayerElement.play().catch(err => {
                            console.warn('Autoplay bloqu√©');
                        });
                        
                        console.log('‚úÖ Lecteur HLS initialis√©');
                    });
                    
                    hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                        console.log('HLS Error:', data.type, data.details, data.fatal ? '(FATAL)' : '');
                        
                        if (data.fatal) {
                            switch (data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    console.warn('‚ö†Ô∏è Erreur r√©seau');
                                    hlsPlayer.startLoad();
                                    break;
                                    
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    console.warn('‚ö†Ô∏è Erreur m√©dia');
                                    hlsPlayer.recoverMediaError();
                                    break;
                                    
                                default:
                                    console.error('‚ùå Erreur HLS fatale');
                                    loadingText.textContent = 'Erreur. Passage √† l\'iframe...';
                                    setTimeout(() => {
                                        useIframePlayer(url);
                                    }, 2000);
                                    break;
                            }
                        } else {
                            nonFatalErrorCount++;
                            console.warn(`‚ö†Ô∏è Erreur non fatale ${nonFatalErrorCount}/${MAX_NON_FATAL_ERRORS}`);
                            
                            if (nonFatalErrorCount > MAX_NON_FATAL_ERRORS) {
                                console.error('‚ùå Trop d\'erreurs');
                                setTimeout(() => {
                                    useIframePlayer(url);
                                }, 2000);
                            }
                        }
                    });
                    
                    hlsPlayerElement.addEventListener('timeupdate', () => {
                        if (hlsPlayerElement.currentTime > 0 && !hlsPlayerElement.paused) {
                            saveProgressThrottled(hlsPlayerElement.currentTime);
                        }
                    });
                    
                    hlsPlayerElement.addEventListener('ended', () => {
                        saveProgress(hlsPlayerElement.duration, true);
                    });
                    
                } else if (hlsPlayerElement.canPlayType('application/vnd.apple.mpegurl')) {
                    hlsPlayerElement.src = streamUrl;
                    loadingOverlay.style.display = 'none';
                    hlsPlayerElement.style.display = 'block';
                    playerInitialized = true;
                    
                    const savedTime = {{ time_position }};
                    if (savedTime > 0) {
                        hlsPlayerElement.currentTime = savedTime;
                    }
                    
                    hlsPlayerElement.play().catch(() => {});
                    
                    hlsPlayerElement.addEventListener('timeupdate', () => {
                        if (hlsPlayerElement.currentTime > 0 && !hlsPlayerElement.paused) {
                            saveProgressThrottled(hlsPlayerElement.currentTime);
                        }
                    });
                    
                    hlsPlayerElement.addEventListener('ended', () => {
                        saveProgress(hlsPlayerElement.duration, true);
                    });
                    
                    console.log('‚úÖ Lecteur HLS natif (Safari)');
                } else {
                    throw new Error('HLS non support√©');
                }
            }
            
        } catch (error) {
            console.error('‚ùå Erreur initialisation:', error);
            
            loadingText.textContent = 'Chargement avec lecteur standard...';
            setTimeout(() => {
                useIframePlayer(url);
            }, 1500);
        }
    }

    let saveProgressTimeout = null;
    function saveProgressThrottled(currentTime) {
        if (saveProgressTimeout) return;
        
        saveProgressTimeout = setTimeout(() => {
            saveProgress(currentTime, false);
            saveProgressTimeout = null;
        }, 5000);
    }

    function saveProgress(currentTime, completed) {
        fetch('/save-progress', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({
                'anime_id': animeId,
                'season_number': seasonNumber,
                'episode_number': episodeNumber,
                'time_position': currentTime,
                'completed': completed
            })
        }).catch(error => console.error('Erreur sauvegarde progression:', error));
    }

    async function downloadEpisode() {
        const downloadBtn = document.getElementById('downloadBtn');
        const progressBar = document.getElementById('downloadProgress');
        const progressText = document.getElementById('downloadText');

        downloadBtn.disabled = true;
        downloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Pr√©paration...';
        progressBar.style.display = 'block';
        progressText.textContent = "Pr√©paration du t√©l√©chargement...";
        
        try {
            if (useSegmentation && currentVideoKey) {
                const downloadUrl = `/api/video/download/${encodeURIComponent(currentVideoKey)}`;
                
                progressText.textContent = "T√©l√©chargement en cours...";
                progressText.style.color = "#4CAF50";
                
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = `{{ anime.title }} - S{{ season.season_number }}E{{ episode.episode_number }}.mp4`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                console.log('‚úÖ T√©l√©chargement lanc√©');
                
            } else {
                progressText.textContent = "Ouverture de la source...";
                progressText.style.color = "#4CAF50";
                
                window.open(videoUrl, '_blank');
                
                console.log('‚úÖ Source ouverte dans un nouvel onglet');
            }
            
        } catch (error) {
            console.error('‚ùå Erreur t√©l√©chargement:', error);
            progressText.textContent = "√âchec du t√©l√©chargement.";
            progressText.style.color = "#F44336";
        } finally {
            setTimeout(() => {
                downloadBtn.disabled = false;
                downloadBtn.innerHTML = '<i class="fas fa-download"></i> T√©l√©charger';
                if (progressText.style.color !== "#F44336") {
                    progressBar.style.display = 'none';
                }
            }, 3000);
        }
    }

    window.addEventListener('beforeunload', () => {
        if (useSegmentation && playerInitialized) {
            const hlsPlayerElement = document.getElementById('hls-player');
            if (hlsPlayerElement.currentTime > 0) {
                saveProgress(hlsPlayerElement.currentTime, false);
            }
        }
    });

    // ============================================
    // CUSTOM TAP CONTROLS
    // ============================================
    function initializeTripleTap() {
        const playerWrapper = document.querySelector('.player-wrapper');
        const videoContainer = document.querySelector('.video-container');
        const hlsPlayerElement = document.getElementById('hls-player');
        const iframePlayer = document.getElementById('iframe-player');
        const tapIndicatorLeft = document.getElementById('tap-indicator-left');
        const tapIndicatorRight = document.getElementById('tap-indicator-right');
        const tapText = document.getElementById('tap-text');

        let tapCount = 0;
        let tapTimer = null;
        let lastTapTime = 0;
        let lastTapX = 0;
        let lastTapSide = null;
        let clickActionTimer = null;

        // Constantes
        const TAP_DELAY = 300; // ms entre chaque tap pour double/triple
        const SINGLE_CLICK_DELAY = 250; // ms d'attente pour d√©tecter si c'est un simple clic
        const SEEK_SECONDS = 10; // secondes √† avancer/reculer

        // D√©sactiver le double-clic natif pour plein √©cran
        playerWrapper.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        hlsPlayerElement.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        function getActivePlayer() {
            if (useSegmentation) {
                return hlsPlayerElement;
            }
            return null;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Entrer en plein √©cran
                if (videoContainer.requestFullscreen) {
                    videoContainer.requestFullscreen();
                } else if (videoContainer.webkitRequestFullscreen) {
                    videoContainer.webkitRequestFullscreen();
                } else if (videoContainer.mozRequestFullScreen) {
                    videoContainer.mozRequestFullScreen();
                } else if (videoContainer.msRequestFullscreen) {
                    videoContainer.msRequestFullscreen();
                }
                console.log('üñ•Ô∏è Plein √©cran activ√©');
            } else {
                // Sortir du plein √©cran
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                console.log('üñ•Ô∏è Plein √©cran d√©sactiv√©');
            }
        }

        function showTapIndicator(direction, seconds) {
            const indicator = direction === 'left' ? tapIndicatorLeft : tapIndicatorRight;
            const text = direction === 'left' ? `-${seconds}s` : `+${seconds}s`;
            
            indicator.classList.add('show');
            tapText.textContent = text;
            tapText.classList.add('show');

            setTimeout(() => {
                indicator.classList.remove('show');
            }, 500);

            setTimeout(() => {
                tapText.classList.remove('show');
            }, 1000);
        }

        function handleDoubleTap(x) {
            const player = getActivePlayer();
            
            if (!player || !player.duration) {
                console.log('‚ö†Ô∏è Lecteur non disponible');
                return;
            }

            const wasPlaying = !player.paused;
            const playerWidth = playerWrapper.offsetWidth;
            const isLeftSide = x < playerWidth / 2;

            if (isLeftSide) {
                const newTime = Math.max(0, player.currentTime - SEEK_SECONDS);
                player.currentTime = newTime;
                showTapIndicator('left', SEEK_SECONDS);
                console.log(`‚è™ Reculer de ${SEEK_SECONDS}s ‚Üí ${newTime.toFixed(1)}s`);
            } else {
                const newTime = Math.min(player.duration, player.currentTime + SEEK_SECONDS);
                player.currentTime = newTime;
                showTapIndicator('right', SEEK_SECONDS);
                console.log(`‚è© Avancer de ${SEEK_SECONDS}s ‚Üí ${newTime.toFixed(1)}s`);
            }

            if (wasPlaying) {
                setTimeout(() => {
                    player.play().catch(err => console.warn('Erreur play:', err));
                }, 50);
            }
        }

        function handleSingleClick() {
            const player = getActivePlayer();
            if (!player) return;

            // Toggle play/pause
            if (player.paused) {
                player.play().catch(err => console.warn('Erreur play:', err));
                console.log('‚ñ∂Ô∏è Lecture');
            } else {
                player.pause();
                console.log('‚è∏Ô∏è Pause');
            }
        }

        // Gestionnaire de tap unifi√©
        function handleTap(event) {
            // Ignorer les clics sur les contr√¥les natifs
            if (event.target.tagName === 'VIDEO' && event.target.controls) {
                const rect = event.target.getBoundingClientRect();
                const y = event.clientY - rect.top;
                const videoHeight = rect.height;
                
                // Si clic dans les 15% du bas (zone des contr√¥les), ignorer
                if (y > videoHeight * 0.85) {
                    return;
                }
            }

            const currentTime = Date.now();
            const timeSinceLastTap = currentTime - lastTapTime;

            const x = event.type.startsWith('touch') 
                ? event.touches[0]?.clientX || event.changedTouches[0]?.clientX 
                : event.clientX;

            const playerWidth = playerWrapper.offsetWidth;
            const isLeftSide = x < playerWidth / 2;
            const currentSide = isLeftSide ? 'left' : 'right';

            // Reset si trop de temps ou changement de c√¥t√©
            if (timeSinceLastTap > TAP_DELAY || currentSide !== lastTapSide) {
                tapCount = 0;
            }

            tapCount++;
            lastTapTime = currentTime;
            lastTapX = x;
            lastTapSide = currentSide;

            console.log(`üëÜ Tap ${tapCount}/3 (${currentSide})`);

            // Clear les timers pr√©c√©dents
            if (tapTimer) {
                clearTimeout(tapTimer);
            }
            if (clickActionTimer) {
                clearTimeout(clickActionTimer);
            }

            // TRIPLE TAP = PLEIN √âCRAN
            if (tapCount === 3) {
                event.preventDefault();
                event.stopPropagation();
                toggleFullscreen();
                tapCount = 0;
                lastTapSide = null;
                return;
            }

            // DOUBLE TAP = AVANCER/RECULER
            if (tapCount === 2) {
                event.preventDefault();
                event.stopPropagation();
                
                // Attendre un peu pour voir si c'est un triple tap
                tapTimer = setTimeout(() => {
                    if (tapCount === 2) {
                        handleDoubleTap(x);
                        tapCount = 0;
                        lastTapSide = null;
                    }
                }, TAP_DELAY);
                return;
            }

            // SIMPLE CLICK = PLAY/PAUSE (apr√®s d√©lai)
            if (tapCount === 1) {
                event.preventDefault();
                event.stopPropagation();
                
                clickActionTimer = setTimeout(() => {
                    if (tapCount === 1) {
                        handleSingleClick();
                        tapCount = 0;
                        lastTapSide = null;
                    }
                }, SINGLE_CLICK_DELAY);
            }
        }

        // Ajouter les event listeners
        playerWrapper.addEventListener('click', handleTap);
        playerWrapper.addEventListener('touchend', handleTap, { passive: false });

        console.log('‚úÖ Contr√¥les personnalis√©s activ√©s:');
        console.log('   ‚Ä¢ Simple clic = Play/Pause');
        console.log('   ‚Ä¢ Double tap = Avancer/Reculer 10s');
        console.log('   ‚Ä¢ Triple tap = Plein √©cran');
    }
</script>
{% endif %}
{% endblock %}