{% extends 'base_new.html' %}

{% block title %}{{ anime.title }} - S{{ season.season_number }}E{{ episode.episode_number }} - Anime Zone{% endblock %}

{% block content %}
<div class="container" style="margin-top: 2rem;">
    <!-- Breadcrumb -->
    <div style="margin-bottom: 1.5rem;">
        <a href="/" style="color: var(--text-secondary);">Accueil</a>
        <span style="color: var(--text-muted); margin: 0 0.5rem;">/</span>
        <a href="/anime/{{ anime.anime_id if anime.anime_id else anime.id }}" style="color: var(--text-secondary);">{{ anime.title }}</a>
        <span style="color: var(--text-muted); margin: 0 0.5rem;">/</span>
        <span style="color: var(--text-primary);">S{{ season.season_number }}E{{ episode.episode_number }}: {{ episode.title }}</span>
    </div>

    <!-- Video Player -->
    <div class="video-container">
        <div class="player-wrapper">
            <!-- Lecteur vid√©o HLS (pour Vidmoly et SendVid) -->
            <video id="hls-player" 
                   controls 
                   style="width: 100%; height: 100%; background: #000; display: none;">
            </video>
            
            <!-- Iframe (pour tous les autres lecteurs) -->
            <iframe id="iframe-player" 
                    src="{{ download_url }}" 
                    allow="autoplay; fullscreen" 
                    frameborder="0"
                    referrerpolicy="no-referrer"
                    allowfullscreen
                    style="width: 100%; height: 100%; border: none; display: none;">
            </iframe>
            
            <!-- Message de chargement -->
            <div id="loading-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10;">
                <div style="text-align: center; color: white;">
                    <div class="spinner-border" role="status" style="width: 3rem; height: 3rem; margin-bottom: 1rem;">
                        <span class="visually-hidden">Chargement...</span>
                    </div>
                    <p id="loading-text">D√©tection du lecteur...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Information sur la source vid√©o -->
    <div style="margin-top: 0.5rem; margin-bottom: 1rem; text-align: center; font-size: 0.85rem; color: var(--text-muted);">
        <span id="source-info">
            Source: Chargement...
        </span>

        {% if episode.languages and episode.languages|length > 0 %}
            - Langues disponibles: {{ episode.languages|join(', ') }}
        {% endif %}
    </div>

    <!-- Episode Info -->
    <div style="margin-bottom: 2rem;">
        <h1 style="font-size: 1.75rem; margin-bottom: 0.5rem;">{{ episode.title }}</h1>
        <div style="display: flex; align-items: center; margin-bottom: 1rem;">
            <span style="color: var(--accent-color); font-weight: 600;">Saison {{ season.season_number }}, √âpisode {{ episode.episode_number }}</span>
            <span style="margin: 0 0.75rem; color: var(--text-muted);">‚Ä¢</span>
            <span style="color: var(--text-secondary);">{{ anime.title }}</span>
        </div>
        <p style="color: var(--text-secondary);">{{ episode.description }}</p>
    </div>

    <!-- Episode Navigation -->
    <div class="player-controls">
        <div class="episode-navigation">
            <!-- Previous Episode Button -->
            {% if episode.episode_number > 1 %}
            <a href="/player/{{ anime.anime_id if anime.anime_id else anime.id }}/{{ season.season_number }}/{{ episode.episode_number - 1 }}" class="btn btn-outline">
                <i class="fas fa-step-backward"></i> √âpisode pr√©c√©dent
            </a>
            {% else %}
            <button class="btn btn-outline" disabled style="opacity: 0.5;">
                <i class="fas fa-step-backward"></i> √âpisode pr√©c√©dent
            </button>
            {% endif %}

            <!-- Download Button -->
            <button id="downloadBtn" onclick="downloadEpisode()" class="btn btn-primary">
                <i class="fas fa-download"></i> T√©l√©charger l'√©pisode
            </button>
            <div id="downloadProgress" style="display:none; margin-top: 5px;">
                <div class="progress" style="height: 10px;">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 100%"></div>
                </div>
                <span id="downloadText" style="font-size: 0.8rem; color: var(--text-muted); margin-top: 5px;"></span>
            </div>

            <!-- Next Episode Button -->
            {% if episode.episode_number < season.episodes|length %}
            <a href="/player/{{ anime.anime_id if anime.anime_id else anime.id }}/{{ season.season_number }}/{{ episode.episode_number + 1 }}" class="btn btn-outline next-episode">
                √âpisode suivant <i class="fas fa-step-forward"></i>
            </a>
            {% else %}
            <button class="btn btn-outline" disabled style="opacity: 0.5;">
                √âpisode suivant <i class="fas fa-step-forward"></i>
            </button>
            {% endif %}
        </div>

        <a href="/anime/{{ anime.anime_id if anime.anime_id else anime.id }}" class="btn btn-primary">
            <i class="fas fa-list"></i> Tous les √©pisodes
        </a>
    </div>
</div>
{% endblock %}

{% block styles %}
<style>
    .video-container {
        position: relative;
        width: 100%;
        background: #000;
        border-radius: 8px;
        overflow: hidden;
    }

    .player-wrapper {
        position: relative;
        width: 100%;
        height: 0;
        padding-bottom: 56.25%;
        background-color: #000;
        overflow: hidden;
    }

    .player-wrapper video,
    .player-wrapper iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: none;
    }

    .spinner-border {
        border: 0.25em solid rgba(255, 255, 255, 0.2);
        border-right-color: #fff;
        border-radius: 50%;
        animation: spinner-border 0.75s linear infinite;
    }

    @keyframes spinner-border {
        to { transform: rotate(360deg); }
    }
</style>
{% endblock %}

{% block scripts %}
<!-- HLS.js pour la lecture des vid√©os segment√©es -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

{% if current_user.is_authenticated %}
<script>
    const animeId = {{ anime.anime_id if anime.anime_id else anime.id }};
    const seasonNumber = {{ season.season_number }};
    const episodeNumber = {{ episode.episode_number }};
    const videoUrl = "{{ download_url }}";
    
    let hlsPlayer = null;
    let currentVideoKey = null;
    let useSegmentation = false;
    let playerInitialized = false;

    document.addEventListener('DOMContentLoaded', function() {
        // Enregistrer la progression initiale
        saveProgress(0, false);
        
        // D√©terminer le type de lecteur
        const videoUrlLower = videoUrl.toLowerCase();
        
        // ‚ö° IMPORTANT: D√©tecter UNIQUEMENT Vidmoly et SendVid pour la segmentation
        if (videoUrlLower.includes('vidmoly') || videoUrlLower.includes('sendvid')) {
            console.log('üé¨ Lecteur segment√© d√©tect√©:', videoUrl);
            useSegmentation = true;
            initializeSegmentedPlayer();
        } else {
            // Tous les autres lecteurs ‚Üí iframe directement
            console.log('üñºÔ∏è Lecteur iframe:', videoUrl);
            useIframePlayer();
        }
    });

    // Utiliser le lecteur iframe (pour tous les lecteurs non support√©s)
    function useIframePlayer() {
        const iframePlayer = document.getElementById('iframe-player');
        const loadingOverlay = document.getElementById('loading-overlay');
        const sourceInfo = document.getElementById('source-info');
        
        // D√©tecter le type de lecteur
        let playerName = 'Lecteur externe';
        const urlLower = videoUrl.toLowerCase();
        
        if (urlLower.includes('sibnet')) playerName = 'Sibnet';
        else if (urlLower.includes('oneupload')) playerName = 'OneUpload';
        else if (urlLower.includes('mixdrop')) playerName = 'MixDrop';
        else if (urlLower.includes('doodstream')) playerName = 'DoodStream';
        else if (urlLower.includes('streamwish')) playerName = 'StreamWish';
        else if (urlLower.includes('streamtape')) playerName = 'StreamTape';
        else if (urlLower.includes('drive.google.com')) playerName = 'Google Drive';
        
        sourceInfo.textContent = `Source: ${playerName} (iframe)`;
        
        // Afficher l'iframe
        iframePlayer.style.display = 'block';
        loadingOverlay.style.display = 'none';
        playerInitialized = true;
        
        console.log('‚úÖ Iframe initialis√©e:', playerName);
    }

    // ========================================
    // üî• FONCTION PRINCIPALE CORRIG√âE
    // ========================================
    async function initializeSegmentedPlayer() {
        const hlsPlayerElement = document.getElementById('hls-player');
        const iframePlayer = document.getElementById('iframe-player');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const sourceInfo = document.getElementById('source-info');
        
        loadingText.textContent = 'D√©tection du type de lecteur...';
        
        try {
            // Appeler l'API pour obtenir les infos vid√©o
            const infoResponse = await fetch('/api/video/info', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: videoUrl })
            });
            
            const info = await infoResponse.json();
            
            // Si l'API retourne une erreur, passer √† l'iframe
            if (!info.success) {
                console.warn('‚ö†Ô∏è Segmentation non disponible:', info.error);
                
                if (info.use_iframe) {
                    loadingText.textContent = 'Chargement avec lecteur standard...';
                    setTimeout(() => {
                        useIframePlayer();
                    }, 1000);
                    return;
                }
                
                throw new Error(info.error || '√âchec de la d√©tection');
            }
            
            currentVideoKey = info.video_key;
            const playerType = info.player_type.toUpperCase();
            
            console.log(`‚úÖ ${playerType} d√©tect√©`);
            
            // ========================================
            // üî• DISTINCTION CRITIQUE : SENDVID vs VIDMOLY
            // ========================================
            
            if (info.player_type === 'sendvid' && info.direct_mp4) {
                // ===== SENDVID : MP4 DIRECT (pas de HLS.js) =====
                console.log('üé¨ SendVid d√©tect√© : utilisation lecteur HTML5 natif');
                
                sourceInfo.textContent = `Source: SENDVID (Streaming MP4 direct)`;
                loadingText.textContent = 'Chargement SendVid...';
                
                // URL du stream MP4
                const streamUrl = `/api/video/stream/${encodeURIComponent(currentVideoKey)}`;
                
                // Utiliser le lecteur HTML5 natif directement
                hlsPlayerElement.src = streamUrl;
                
                hlsPlayerElement.addEventListener('loadedmetadata', () => {
                    loadingOverlay.style.display = 'none';
                    hlsPlayerElement.style.display = 'block';
                    playerInitialized = true;
                    
                    const savedTime = {{ time_position }};
                    if (savedTime > 0 && savedTime < hlsPlayerElement.duration) {
                        hlsPlayerElement.currentTime = savedTime;
                    }
                    
                    hlsPlayerElement.play().catch(err => {
                        console.warn('Autoplay bloqu√©, attente interaction utilisateur');
                    });
                    
                    console.log('‚úÖ Lecteur SendVid MP4 initialis√©');
                }, { once: true });
                
                hlsPlayerElement.addEventListener('error', (e) => {
                    console.error('‚ùå Erreur lecteur SendVid:', e);
                    loadingText.textContent = 'Erreur de lecture. Passage √† l\'iframe...';
                    setTimeout(() => {
                        useIframePlayer();
                    }, 2000);
                });
                
                // Sauvegarder la progression
                hlsPlayerElement.addEventListener('timeupdate', () => {
                    if (hlsPlayerElement.currentTime > 0 && !hlsPlayerElement.paused) {
                        saveProgressThrottled(hlsPlayerElement.currentTime);
                    }
                });
                
                hlsPlayerElement.addEventListener('ended', () => {
                    saveProgress(hlsPlayerElement.duration, true);
                });
                
                // Logs de debug
                hlsPlayerElement.addEventListener('waiting', () => {
                    console.log('‚è≥ Buffering SendVid...');
                });
                
                hlsPlayerElement.addEventListener('playing', () => {
                    console.log('‚ñ∂Ô∏è Lecture SendVid');
                });
                
            } else {
                // ===== VIDMOLY : HLS AVEC HLS.JS =====
                console.log('üé¨ Vidmoly d√©tect√© : utilisation HLS.js');
                
                sourceInfo.textContent = `Source: ${playerType} (HLS Segment√© - ${info.segments || '?'} segments)`;
                loadingText.textContent = `Chargement ${playerType}...`;
                
                const streamUrl = `/api/video/stream/${encodeURIComponent(currentVideoKey)}`;
                
                if (Hls.isSupported()) {
                    hlsPlayer = new Hls({
                        debug: false,
                        enableWorker: true,
                        lowLatencyMode: false,
                        backBufferLength: 90,
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60,
                        maxBufferSize: 60 * 1000 * 1000,
                        maxBufferHole: 0.5,
                        highBufferWatchdogPeriod: 3,
                        nudgeOffset: 0.1,
                        nudgeMaxRetry: 5,
                        manifestLoadingTimeOut: 20000,
                        manifestLoadingMaxRetry: 4,
                        levelLoadingTimeOut: 20000,
                        levelLoadingMaxRetry: 4,
                        fragLoadingTimeOut: 30000,
                        fragLoadingMaxRetry: 6
                    });
                    
                    hlsPlayer.loadSource(streamUrl);
                    hlsPlayer.attachMedia(hlsPlayerElement);
                    
                    let nonFatalErrorCount = 0;
                    const MAX_NON_FATAL_ERRORS = 10;
                    
                    hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                        loadingOverlay.style.display = 'none';
                        hlsPlayerElement.style.display = 'block';
                        playerInitialized = true;
                        
                        const savedTime = {{ time_position }};
                        if (savedTime > 0) {
                            hlsPlayerElement.currentTime = savedTime;
                        }
                        
                        hlsPlayerElement.play().catch(err => {
                            console.warn('Autoplay bloqu√©');
                        });
                        
                        console.log('‚úÖ Lecteur HLS initialis√©');
                    });
                    
                    hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                        console.log('HLS Error:', data.type, data.details, data.fatal ? '(FATAL)' : '');
                        
                        if (data.fatal) {
                            switch (data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    console.warn('‚ö†Ô∏è Erreur r√©seau');
                                    hlsPlayer.startLoad();
                                    break;
                                    
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    console.warn('‚ö†Ô∏è Erreur m√©dia');
                                    hlsPlayer.recoverMediaError();
                                    break;
                                    
                                default:
                                    console.error('‚ùå Erreur HLS fatale');
                                    loadingText.textContent = 'Erreur. Passage √† l\'iframe...';
                                    setTimeout(() => {
                                        useIframePlayer();
                                    }, 2000);
                                    break;
                            }
                        } else {
                            nonFatalErrorCount++;
                            console.warn(`‚ö†Ô∏è Erreur non fatale ${nonFatalErrorCount}/${MAX_NON_FATAL_ERRORS}`);
                            
                            if (nonFatalErrorCount > MAX_NON_FATAL_ERRORS) {
                                console.error('‚ùå Trop d\'erreurs');
                                setTimeout(() => {
                                    useIframePlayer();
                                }, 2000);
                            }
                        }
                    });
                    
                    hlsPlayer.on(Hls.Events.FRAG_LOADING, (event, data) => {
                        console.log(`üîÑ Chargement segment ${data.frag.sn}`);
                    });
                    
                    hlsPlayer.on(Hls.Events.FRAG_LOADED, (event, data) => {
                        console.log(`‚úÖ Segment ${data.frag.sn} charg√©`);
                        nonFatalErrorCount = Math.max(0, nonFatalErrorCount - 1);
                    });
                    
                    hlsPlayerElement.addEventListener('timeupdate', () => {
                        if (hlsPlayerElement.currentTime > 0 && !hlsPlayerElement.paused) {
                            saveProgressThrottled(hlsPlayerElement.currentTime);
                        }
                    });
                    
                    hlsPlayerElement.addEventListener('ended', () => {
                        saveProgress(hlsPlayerElement.duration, true);
                    });
                    
                    hlsPlayerElement.addEventListener('waiting', () => {
                        console.log('‚è≥ Buffering...');
                    });
                    
                    hlsPlayerElement.addEventListener('playing', () => {
                        console.log('‚ñ∂Ô∏è Lecture');
                    });
                    
                } else if (hlsPlayerElement.canPlayType('application/vnd.apple.mpegurl')) {
                    // Support natif HLS (Safari)
                    hlsPlayerElement.src = streamUrl;
                    loadingOverlay.style.display = 'none';
                    hlsPlayerElement.style.display = 'block';
                    playerInitialized = true;
                    
                    const savedTime = {{ time_position }};
                    if (savedTime > 0) {
                        hlsPlayerElement.currentTime = savedTime;
                    }
                    
                    hlsPlayerElement.play().catch(() => {});
                    
                    hlsPlayerElement.addEventListener('timeupdate', () => {
                        if (hlsPlayerElement.currentTime > 0 && !hlsPlayerElement.paused) {
                            saveProgressThrottled(hlsPlayerElement.currentTime);
                        }
                    });
                    
                    hlsPlayerElement.addEventListener('ended', () => {
                        saveProgress(hlsPlayerElement.duration, true);
                    });
                    
                    console.log('‚úÖ Lecteur HLS natif (Safari)');
                } else {
                    throw new Error('HLS non support√©');
                }
            }
            
        } catch (error) {
            console.error('‚ùå Erreur initialisation:', error);
            
            loadingText.textContent = 'Chargement avec lecteur standard...';
            setTimeout(() => {
                useIframePlayer();
            }, 1500);
        }
    }

    // Sauvegarder la progression (throttled)
    let saveProgressTimeout = null;
    function saveProgressThrottled(currentTime) {
        if (saveProgressTimeout) return;
        
        saveProgressTimeout = setTimeout(() => {
            saveProgress(currentTime, false);
            saveProgressTimeout = null;
        }, 5000);
    }

    // Fonction de sauvegarde de progression
    function saveProgress(currentTime, completed) {
        fetch('/save-progress', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({
                'anime_id': animeId,
                'season_number': seasonNumber,
                'episode_number': episodeNumber,
                'time_position': currentTime,
                'completed': completed
            })
        }).catch(error => console.error('Erreur sauvegarde progression:', error));
    }

    // Fonction de t√©l√©chargement
    async function downloadEpisode() {
        const downloadBtn = document.getElementById('downloadBtn');
        const progressBar = document.getElementById('downloadProgress');
        const progressText = document.getElementById('downloadText');

        downloadBtn.disabled = true;
        downloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Pr√©paration...';
        progressBar.style.display = 'block';
        progressText.textContent = "Pr√©paration du t√©l√©chargement...";
        
        try {
            if (useSegmentation && currentVideoKey) {
                // T√©l√©chargement via syst√®me de segmentation
                const downloadUrl = `/api/video/download/${encodeURIComponent(currentVideoKey)}`;
                
                progressText.textContent = "T√©l√©chargement en cours...";
                progressText.style.color = "#4CAF50";
                
                // Cr√©er un lien de t√©l√©chargement
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = `{{ anime.title }} - S{{ season.season_number }}E{{ episode.episode_number }}.mp4`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                console.log('‚úÖ T√©l√©chargement lanc√©');
                
            } else {
                // T√©l√©chargement classique (iframe) - ouvrir la source
                progressText.textContent = "Ouverture de la source...";
                progressText.style.color = "#4CAF50";
                
                window.open(videoUrl, '_blank');
                
                console.log('‚úÖ Source ouverte dans un nouvel onglet');
            }
            
        } catch (error) {
            console.error('‚ùå Erreur t√©l√©chargement:', error);
            progressText.textContent = "√âchec du t√©l√©chargement.";
            progressText.style.color = "#F44336";
        } finally {
            setTimeout(() => {
                downloadBtn.disabled = false;
                downloadBtn.innerHTML = '<i class="fas fa-download"></i> T√©l√©charger l\'√©pisode';
                if (progressText.style.color !== "#F44336") {
                    progressBar.style.display = 'none';
                }
            }, 3000);
        }
    }

    // Sauvegarder avant de quitter
    window.addEventListener('beforeunload', () => {
        if (useSegmentation && playerInitialized) {
            const hlsPlayerElement = document.getElementById('hls-player');
            if (hlsPlayerElement.currentTime > 0) {
                saveProgress(hlsPlayerElement.currentTime, false);
            }
        }
    });
</script>
{% endif %}
{% endblock %}